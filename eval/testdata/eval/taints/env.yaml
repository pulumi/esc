imports:
  - a: {rotateOnly: true}
values:
  rotateOnly-ref-not-allowed: ${imports["a"].a_value} # error!

  open-cannot-use-rotateOnly-values:
    fn::open::schema:
      string: ${imports["a"].a_value} # error!

  rotateOnly-input-with-rotateOnly-value:
    fn::rotate::example:
      inputs:
        rotateOnly: ${imports["a"].a_value} # ok!

  rotateOnly-taint-propagates-through-interpolation:
    fn::rotate::example:
      inputs:
        rotateOnly: Bearer ${imports["a"].a_value} # ok!

  rotateOnly-input-without-rotateOnly-value:
    fn::rotate::example:
      inputs:
        rotateOnly: "not-rotateOnly" # warn!

#  non-rotateOnly-input-with-rotateOnly-value:
#    fn::rotate::example:
#      inputs:
#        plain: ${imports["a"].a_value}  # this isn't allowed, but should it be, since it's within a fn::rotate?

  rotateOnly-with-inline-import:
    fn::rotate::example:
      inputs:
        rotateOnly: ${imports.b.b_value}

# two cases that work non-intuitively:
#
# here a_transitive resolves first because it's sorted before rotateOnly-with-inline-import2
# this causes the ${imports.b.b_value} import to be RotateOnly: false
#
#  a_transitive: ${imports.b.b_value}
#  rotateOnly-with-inline-import2:
#    fn::rotate::example:
#      inputs:
#        rotateOnly: ${imports.b.b_value}
